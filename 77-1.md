# 코드스피츠 77 ES6+ 1회차 요약

이 강의는 코드스피츠의 강의를 바탕으로 요약을 한 것입니다. 모든 저작권은 코드스피츠에 있으며 문제시 삭제하겠습니다.
영상 링크: https://www.youtube.com/watch?v=0j_eGoF8Q98&t=6031s



## Program과 Timing

### 컴파일 언어의 라이프 사이클

1. Language code **(Lint Time)**

2. Machine Language **(Compile Time)** : 컴파일러가 Language code를 Machine Language로 바꾼다. 이 때 실제로 메모리에 적재(**Load**)되기 전이므로 컴파일러가 가상 메모리(Virtual Memory)를 이용하여 실행을 해 본다. 그리고 4단계 Load 과정에서 가상 메모리 A를 진짜 메모리 A와 Mapping해주는데 이것을 Virtual Memory Mapping Table 이라고 하여 **VTable**이라고 부른다. 컴파일러 언어들은 이 과정이 모두 존재한다.

3. File

   ---
   > 이 아래의 4단계부터가 프로그램의 정의에 부합하는 단계. File에서 부터 Load해서 주 메모리에 적재된 상태가 Program이라고 지칭할 수 있는 단계.

4. Load

   > 여기 4단계까지가 프로그래머의 영역. 실행과 종료는 컴퓨터가 하므로 제외.
   ---

5. Run **(Run Time)**

   1. Loading
      1. Memory에 추상적인 명령, 값으로 나누어 저장
   2. Instrunction fetch & decoding
      1. Instrunction : <u>해당 CPU가 해석할 수 있는 명령어 부분</u> 즉, 연산 유닛이 fetch와 decoding을 하는 것이 instrunction fetch & decoding
         1. 외부 버스를 통해 추상적인 명령, 값을 제어유닛으로 가져온다.(**fetch**)
         2. 제어 유닛에서 fetch된 추상적인 명령을 CPU가 알 수 있는 명령으로 번역한다. (**decoding**)
         3. decoding 된 명령이 연산 유닛으로 이동하여 연산되어 처리된다.
         4. 그런데 연산은 단순 연산만 존재하지 않는다. 연산에 필요한 값도 필요하다. 따라서 Memory에 저장되어 있는 값을 데이터 유닛으로 가져와서 loading해놓고 명령에 따라 필요한 값을 연산 유닛에 넘겨줘야 한다. (2+5라면 2와 5를 넘겨줘야 하는 것.)
   3. execution
      1. 연산 유닛에서 연산을 실행한 결과 값인 7이 나오면 이 값은 다시 데이터 유닛으로 이동한다.
         1. 7을 데이터 유닛에서 지울건지, 다시 메모리로 보낼 건지를 결정
      2. 데이터 유닛의 7이 다시 값으로 메모리에 저장된다.

   * 이러한 한 사이클을 가진 명령들을 모두 처리하면 프로그램이 종료된다. 따라서 프로그램은 파일을 메모리에 적재해서 순차적으로 실행하고 실행이 다 되면 종료되는 것. 프로그램은 명령과 값의 집합(파일)이라고 볼 수 있고, 이 프로그램을 CPU가 소비하는 것. 이것이 바로 <u>노이만 머신의 구조</u>이다.

   ---

   ##### Runtime의 좀 더 자세한 과정 묘사

   1. 필수적인 정의를 먼저 로딩(essential definition loading)
   2. 가상 메모리와 진짜 메모리를 맵핑(VTable Mapping)
   3. 실행(Run)
   4. 실행 중에 새로운 정의가 생기기도 함 (Runtime definition loading)
   5. 새로운 정의를 바탕으로 종료될 때까지 실행(Run)

6. Terminate

### 스크립트 언어의 라이프 사이클

위의 컴파일 언어와 스크립트의 언어는 다르다. Js가 실행되면 Compile Time 없이 무조건 Run Time이다. Run time에 script src를 통해서 불러온 것은 **1) 기본이 되는 함수의 정의(클래스 정의)를 가져오고**, 우리는 이 기본 정의들을 가지고 **2) 확장된 함수의 정의(커스텀 함수, 커스텀 클래스, 사이트에서 쓸 구조물, 기본 데이터 블럭 등)를 만든다.** 그리고 우리는 이 **3) 정의된 함수와 클래스를 사용한다.** 결국 같은 Run time이더라도 상대적인 순서는 존재하고 있다. 따라서 먼저 실행되는 단계를 Static time, 이후의 단계를 Run time으로 구분한다. 이 개념은 굉장히 상대적이다. 만약 1, 2, 3, 4 단계가 있다면 2단계에게는 1단계가 Static time이고 자신이 Run time이며, 3단계에게는 2단계가 Static Time이고 자신이 Run time이다.

1. Language code **(Lint Time)**
2. File : 컴파일 언어와 달리 바로 js파일이 생성되어 브라우저에 적재 된다.
3. Load
4. Machine Language
5. Run **(Run Time)**
6. Terminate



## Memory, Address, Pointer, Variables, Dispatch

메모리(Memory)가 있고, 메모리 안에는 주소(Address)가 있다. 주소 안에는 주소 값을 나타내는 포인터(Pointer)라는 개념이 있고, 이 모든 것을 아우르는 변수(Variables)라는 개념이 있고 디스패치(Dispatch)라는 개념이 있다. 사실 이 부분의 목적은 디스패치의 개념을 배우는것이다.

### 진짜 메모리에 적재된 프로그램이 작동하는 방식

진짜 프로그램은 메모리에 적재되어 있으므로 메모리를 이해하는 것이 최우선이다. 그 중 명령은 적재되어서 차근차근 순서대로 실행만 한다. 따라서 우리가 관심을 가질 부분이 많이 없다. 우리가 관심을 가지고 봐야하는 부분은 데이터 부분의 메모리가 어떻게 움직이는 지이다.

결론: 개발할 때 유연성을 위해 참조에 참조를 쓰는데, <u>왜 참조에 참조를 쓰는지를 이해하는 것이 핵심</u>이다.

* 현실에서 참조의 참조를 나타내는 방법
  1. 링크드리스트
  2. 인터페이스와 구상클래스
  3. 클래스와 인스턴스
  4. 디자인 패턴에서는 데코레이터패턴, 비이터패턴, 컴포지트 패턴이 전부 다 링크드리스트 응용이므로 참조에 참조라고 할 수 있다.



### 변수와 메모리

메모리는 고유한 번호를 주소로 같는 블럭체계로 되어 있다. 블럭을 나타내는 주소가 몇 자리인지를 대답할 수 있다. 32비트 컴퓨터는 32비트이고, 64비트 컴퓨터는 64비트이다. 주소가 32비트라는 얘기는 32비트보다 큰 주소는 가질 수 없다는 얘기. 32비트 컴퓨터가 가질 수 있는 최대 메모리의 크기는 4G. 

~~~
A = "TEST" (A에 "TEST" 저장)
&A = 11 (A의 메모리의 주소를 나타내는 연산자 : &) 
B = &A (B에 A의 메모리 주소를 나타내는 연산자를 할당)
*B = "TEST" (B가 가진 A의 메모리 주소를 나타내는 연산자의 진짜 값을 얻는 연산자 : *)
~~~

위의 코드에서 주목해야 할 점.

 	1. 변수에 직접 값을 넣을 수 있다.
 	2. 변수에 &연산자를 통해 다른 변수의 주소 값을 넣을 수 있다.
 	3. 변수는 *연산자를 통해 다른 변수의 주소 값에 해당하는 값을 얻을 수 있다.



변수는 한 번 만들면 계속 퍼져나간다. 공개된 변수를 사용처가 통제가 안 된다.

~~~
A = "TEST" (A에 "TEST" 저장)
&A = 11 (A의 메모리 주소가 11이라고 가정. A의 메모리의 주소를 나타내는 연산자 : &) 
B = &A (B에 A의 메모리 주소를 나타내는 연산자를 할당)
*B = "TEST" (B가 가진 A의 메모리 주소를 나타내는 연산자의 진짜 값을 얻는 연산자 : *)

C = B, D = B, ...(C와 D도 참조 값을 조회하면 &A의 값이 나온다.)
~~~



만약에 B의 값이 바뀌면 어떻게 될까?

~~~
A = "TEST" (A에 "TEST" 저장)
&A = 11 (A의 메모리의 주소를 나타내는 연산자 : &) 
B = &A (B에 A의 메모리 주소를 나타내는 연산자를 할당)
*B = "TEST" (B가 가진 A의 메모리 주소를 나타내는 연산자의 진짜 값을 얻는 연산자 : *)

C = B, D = B, ...(C와 D도 참조 값을 조회하면 &A의 값이 나온다.)

B = &K(K의 메모리 주소가 28이라고 가정)
~~~

이렇게 되면 C와 D는 A의 메모리 주소 11을 나타내는 값을 가지고 있고 B는 K의 메모리 주소 28을 나타내는 값을 가지고 있다.

여기서 무엇이 문제가 되는 것일까?

바로 코드의 명시성에 어긋난다. 

우리는 분명히 ```C=B, D=B``` 라고 코드를 작성했다. 이 코드를 직관적으로 보면 C와 D는 언제나 B와 값이 같아야 한다. 그러나 현재는 실제 값이 달라져있으므로 혼동이 온다. 무심코 C와 D가 B와 같다고 생각하고 코드를 짜게 될 수도 있는 것이다. 이 부분이 개발자들이 힘들어지게 되는 원인이다.

이러한 **직접 참조의 문제**를 해결하는 방법이 **참조의 참조**이다.

함수형 패러다임에서는 '참조를 쓰지 말라'고 한다. '값만 쓰라'고 한다.

객체지향에서는 '직접 참조하지마' 로 해결한다.



A를 직접 참조를 하지 않고 B를 객체로 만들어서 그 안에 value라는 변수가 A의 메모리 주소를 참조한다고 생각해보자.

~~~
//B 객체의 메모리 주소는 01, 변수 value의 값인 A의 메모리 주소는 11, 변수 V의 값은 3이라고 가정
B = {value:&A, V:3}
C = B, D = B, ...
~~~

이 B의 메모리 주소는 value라는 변수도 참조할 수 있어야하고, V라는 변수도 참조할 수 있다.

메모리 상에는 객체인 B를 가리키는 주소와 Ojbect가 소유하고 있는 value, v를 가리키는 주소가 모두 다 만들어진다.

그리고 C와 B에는 B 객체의 메모리 주소인 01이 저장된다.

이렇게 되면 이전의 경우와 달리 B가 직접 A의 메모리 주소를 참조하지 않고 변수 value를 통해 참조하게 만들었다. 이것이 바로 **참조의 참조**이다.

이제부터는 B를 그냥 조회하면 01이 나온다. A를 얻으려면 B를 조회하고 B에서 다시 value를 조회해야 A를 얻을 수 있다. 이러한 경우를 **Double dispatch**라고 부른다. **Dispatch**는 <u>주소로부터 값을 얻는 행위</u>이다. 즉, Double dispatch는 한 번에 값으로 갈 수 있는 Dispatch를 안 되게 만들어 놓은 것.

이 경우에도 위에서처럼 B의 값이 변경된다면 어떨까? 

~~~
//B 객체의 메모리 주소는 01, 변수 value의 값인 A의 메모리 주소는 11, 변수 V의 값은 3이라고 가정
B = {value:&A, V:3}
C = B, D = B, ...

B.value = &K
~~~

Double dispatch가 구현되면 C와 D는 B 객체의 메모리 주소 값을 가지고 있다. 따라서 B.value의 값이 변경된다고 하더라도 C.value, D.value로 조사하면 변경된 &K 값을 얻을 수 있다. 즉 직접 참조의 경우처럼 참조하고 있는 값이 달라지는 것이 아니라 B, C, D 모두 같은 참조 값을 유지하는 것이다. 이것이 바로 **참조의 참조**를 쓰는 이유이다.



그렇다면 우리는 변수를 어떻게 정의할 수 있을까?

변수는 한 마디로, **메모리 주소의 별명**이다. 32비트, 64비트로 이루어진 긴 메모리 주소를 직접 부르는 것은 어렵다. 따라서 이 메모리 주소를 간단하게 부르기 위해 별명을 붙이고 이 별명을 변수라고 하는 것이다. 

변수가 나타내는 정보는 

 	1. 메모리 주소가 어디인지
	2. 메모리 크기를 얼마나 차지하는지
	3. 참조형 변수, 값형 변수등 어떤 타입이 메모리에 들어가는지

이 정보들을 합쳐서 VTable에 저장한다. 그러면 실제로 메모리에 적재되었을 때 Vtable의 참조내용을 보고서 실제 메모리 크기를 참조내용에 적힌대로 확보해서 변수에 진짜 주소를 맵핑해주고 프로그램이 시작되는 것이다.



## Lexical Grammar (문법적 어휘 요소)

자바스크립트는 결국 텍스트로 작성하는 텍스트 문서이다. 이 문서를 구성하고 있는 텍스트의 기본 요소를 알아야한다.

MDN 링크 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Lexical_grammar

* Control Character 제어 문자 : 한글에서는 볼 일이 없다. 동남아권 언어에는 많다.
* White Space 공백 문자 : 공백을 나타내는 문자
* Line Terminators 개행 문자 : 라인을 끊어주는 문자
* Comments 개행 문자 : 주석을 나타내는 문자.
* Keyword 예약어 : 해당 언어에서 특정한 용도로 미리 정해놓은 Keyword들. 이 예약어들을 토큰으로 보고 예약어를 변수나 식별자로 사용하지 못 하게 한다.
* Literals 리터럴 : 더 이상 나눌 수 없는 객체나 값의 표현. 숫자 37에서 3과 7을 더 이상 쪼갤 수 없으므로 37은 숫자 리터럴의 종류 중 하나 인것이다. 자바스크립트에는 숫자 리터럴만 해도 10여종이 존재한다.



## Language Element 

실제로 자바스크립트를 이루고 있는 기초 블록들은 다음과 같다. 자바스크립트에서는 어떻게 개발해도 이 이외에 나오지 않는다. 그런데 이 기초 요소들은 언어마다 다르게 정의되어 있다는 것을 꼭 염두해두고 있을 것.

* Statement 문 : 컴파일러 혹은 실행기한테 주는 힌트. function이라는 문을 사용하게 되면 자바스크립트에서는 문이 아니라 식으로 처리된다. function객체가 만들어져서 값이 되어 버린다. 이것에 비해 while이나 for를 쓰면 어떨까? 반복을 시켜주긴 하지만 이것들을 a에 할당할 수는 없다. 즉, while은 for는 실행하고 나면 흔적없이 사라지는 것이다. 실행은 되지만 실행했던 증거나 결과가 남지 않는다는 얘기. 처리기가 돌아가면서 if, for 등의 문을 만나면 이 힌트를 받아들여서 힌트에 맞게 처리만 할 뿐 메모리에 아무 것도 남지 않는다. 이것이 ```a=for``` 혹은 ```a=if``` 라고 쓸 수 없는 이유이다. 문은 대부분 실행기가 어떤식으로 명령을 실행할지에 대한 제어를 하기 때문에 Control statement라고 하기도 한다. 그래서 제어 구문, 제어문이라고 일컫는 것. 문 대부분이 flow 제어를 사용하기 때문이 그렇다. 그런데 flow 제어가 아닌 것도 많다. 

  * 문을 구분하는 기준 1 - 공문, 식문, 제어문, 선언문

    * 공문 : 아무것도 없는 것을 문으로 인정

      ~~~javascript
      for ( var i = 0; i<5; i++);
      ~~~

      세미콜론으로 공문을 써서 닫아도 에러가 나지 않는다.

      ~~~javascript
      ;;;;;;;;
      ~~~

      세미콜론만 찍었는데도 에러가 나지 않는다. 공문을 인정하기 때문에 그렇다.

    * 식문 : 

    * 제어문 : 흐름 제어를 통해 사용하는 문.

    * 선언문 : var, const, let 등 선언을 목적으로 만들어진 문. 메모리 상에 변수를 할당하는 일. 이렇게 할당하게 되면 적재되면 VTable에 할당하기 위해 VTable도 같이 작성된다. 

  * 문을 구분하는 기준 2 - 단문, 중문 

    원래 문은 하나로 되어 있고 이것을 **단문**이라고 부른다. 그런데 하나의 단문이 들어갈 자리에 여러 개의 단문을 넣고 싶다면 중괄호로 묶을 수 있다. 이 중괄호로 묶을 단문의 묶음을 **중문**이라고 부른다.

    ~~~javascript
    if(true);
    ~~~

    if 제어문의 조건은 엄격하게 형식으로 구분되어 있다. if가 올 수 있고, 공백 문자가 오거나 오지 않을 수 있고, 괄호가 시작되어야 하고, 안에 식이 들어가야 하고 괄호가 닫혀야 하고, 공배 문자가 오거나 오지 않을 수 있고, 그 이후에 반드시 문이 와야한다는 정의를 갖고 있다. 이 문에는 단문이 올 수도 있고, 중문이 올 수도 있다.

    ~~~javascript
    if(true);;
    ~~~

    그런데 위의 코드에 세미콜론을 하나 더 찍는다고 해서 세미콜론이 if 제어문에 딸려있는 것은 아니다. if문의 정의는 괄호 뒤에 문 '하나'만 받기 때문이다. 위와 같은 경우는 그냥 따로 실행된 것이다.

    만약 이 두 문을 다 실행하고 싶다면? 문 하나가 올 수 있는 자리에 중문으로 만들어야 된다.

    ~~~javascript
    if(true){;;}
    ~~~

    이제 아래와 같은 경우를 보자.

    ~~~javascript
    var a,b
    if(true) a=3; b=5;
    //5
    ~~~

    위의 코드는 if 때문에 a와 b가 일어나는 것이 아니라 if 때문에 a가 일어나고 b는 무조건 실행된다는 걸 알 수 있게 되었다. 이것을 묶으려면 반드시 중괄호를 쳐 주어야 한다.

    ~~~javascript
    var a,b
    if(true) {a=3; b=5;}
    //5
    ~~~

    그렇다면 if else문을 보자.

    ~~~javascript
    if(true) a=3; else b=5;
    ~~~

    이 문은 왜 에러가 나지 않을까? if else문은 if문과 상관없는 또 다른 문인데, if else 문의 정의는 if 다음에 괄호 나오고 식나오고 괄호 닫히고 문이 나온 다음에 else가 나온 다음 문이 나온다가 원래 정의이다. 따라서 위의 문은 if else문의 정의에 정확히 부합하므로 에러가 나지 않는다.

    그렇다면 이번에는 중첩된 if else 문을 보자.

    ~~~javascript
    if(true) a=3; else if(a>2) b=3; else b=5;
    ~~~

    자바스크립트에는 if문과 if else문 밖에 없는데, 위의 문은 어떻게 해석되는 것일까? 

    정답은 if else문의 else가 갖고 있는 문이 if else문인 것이다. if else문도 제어문이므로 하나의 '문'인 단문이다. 이러한 문을 해석할 때는 좌결합이라고 하여 왼쪽부터 해석한다. 즉 else 이후를 하나의 문으로 보는것. 따라서 else 이후를 중괄호로 감싸도 상관이 없다.

    중괄호는 자바스크립트에서 여러 가지 다른 의미를 갖고있다.

    1. 중문을 선언할 때 사용
    2. 객체 리터럴을 선언할 때 사용
    3. 함수 리터럴을 선언할 때 사용
    4. 클래스 리터럴을 선언할 때 사용

    그런데 무엇이 다른 것일까? 리터럴을 사용할 때 쓰는 중괄호는 그 결과가 값이 되므로 뒤에 세미콜론을 붙인다. 그런데 중문을 사용할 때 쓰는 중괄호는 세미콜론은 붙이지 않은다. 이렇게 다양하게 쓰이게 되어서 충돌이 날 때가 있다.

    ~~~javascript
    const f = (a) => {}
    ~~~

    위의 코드에서 중괄호는 무슨 뜻일까? 화살표 함수의 바디를 의미하는 것일까, 오브젝트 리터럴을 반환한다는 것일까? 이 경우에는 우리가 식별할 수 없으므로 언어차원에서 미리 정해준다. 이 경우는 무조건 함수의 바디를 의미하는 중괄호가 우선된다. 그렇다면 이 때 우리가 객체를 반환하고 싶다면  return문을 꼭 써야할까? 그건 아니다. 괄호로 묶으면 값으로 인식되므로 괄호로 묶으면 된다.

    ~~~javascript
    const f = (a) => ({a:3});
    ~~~

    

* Expression 식 : 식이란 값이다. 식의 결과는 언제나 하나의 값이 된다. 즉, 값을 표현하는 여러가지 방법을 식이라고 부른다.

  * 값식 : 3, true와 같은 값 자체가 식이다.

  * 연산식 : 연산자와 결합하는 식. 2+3+5와 같은 것이 대표적인 연산식이고 이 연산식의 결과는 하나의 값으로 수렴한다.

  * 호출식 : 함수의 호출을 호출식이라고 부르는데 자바스크립트에서 호출식의 결과는 무엇이 되었든 하나의 값으로 수렴한다. (자바에서 void를 통해 어떤 값을 반환하려고 하면 에러를 내는 것과는 다르다.) 따라서 자바스크립트에서는 호출이 식의 일부이다.

    이 식을 우리는 '문'으로 인정하고, 이것이 바로 '식문'이다.

    ~~~javascript
    3; 5; 6;
    //6
    ~~~

    에러가 안나는 이유는 무엇일까? 하나의 식을 문으로 인정하기 때문이다. 하나의 값식을 식문으로 인정하기 때문이다.

    ~~~javascript
     if(true)3;
    ~~~

    왜 에러가 안날까? 식문이 성립하기 때문이다.

* Identifier 식별자 : 식별자는 대부분 변수를 의미한다. 대부분의 식별자들은 변수기 때문에 변수의 특징들을 소유하게 된다.

  * 기본형, 참조형
  * 변수, 상수



## Sync Flow

우리는 Sync 프로그램, Async 프로그램과 같은 말을 들어본 적이 있다. 그렇다면 Sync는 무슨 의미일까?

제어문은 flow 즉, 흐름을 제어한다. 이 흐름은 무엇일까? 프로그램의 실체는 메모리에 적재되어 있는 명령의 연쇄이다. 그리고 우리는 도중에 이 연쇄를 멈출 수없다. CPU가 명령을 모두 소모할 때까지 우리는 멈출 수 없다. 이 과정이 동기화(Sync) 로직 혹은 흐름이다. 만약 이 Sync flow를 제어할 수 있다고 하면 이것이 바로 Sync flow control이 되는 것이다. 제어문은 이 흐름을 제어 하는 것이다. 무조건 한쪽으로 전진하는 흐름을 바꾸거나 반복하게 할 수 있는 것. 그래서 흐름 제어라고 부르는 것이다.

어떤 흐름은 반복적으로 쓰이기도 한다. 이런 흐름은 Sub flow라고 부르고, 이런 것을 만드는 기능이 언어에 내장되어 있다. 이러한 부분은 flow control과 다르다. 제어 흐름과 다른 것. sub flow는 함수나 클래스를 이용해서 사용한다.